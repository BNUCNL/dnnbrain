#! /usr/bin/env python
# -*- coding: utf-8 -*-

"""
Select top stimuli from provided stimuli for interested layer and channel from
a DNN network.

"""

import numpy as np
import os, argparse
from os.path import join as pjoin
from os.path import exists as pexist
from os.path import basename as pbase
from torch.utils.data import DataLoader
from dnnbrain.dnn.base import ImageSet
from torchvision.transforms import Compose, Resize, ToTensor
from dnnbrain.dnn.core import DNN, Stimulus, Mask, dnn_pooling


def main():

    parser = argparse.ArgumentParser(description='Select top K stimuli from '
                                     'a set of stimulus for interested layers and channels. ')

    parser.add_argument('-net',
                        metavar='DNN_model_name',
                        type=str, required=True,
                        help='Name of interested DNN net.The DNN net should be placed '
                                'in system variable DNNBRAIN_MODEL_DIR with format *.pth . ')

    parser.add_argument('-top',
                        metavar='top_stimulus_num',
                        type=int, required=True,
                        help='Number of top stimulus.For example, top = 5, and the '
                                '*.stim.csv file for top5 image for each pair <layer,channel> '
                                'will be generated. ')

    parser.add_argument('-metric',
                        metavar='metric_of_top_K',
                        type=str, required=True,
                        help='The metric of top K. Available args are: mean, max, L1, L2, median. ')

    parser.add_argument('-stim',
                        metavar='stimulus_path',
                        type=str, required=True,
                        help='A *.stim.csv file contained interested stimuli. ')

    parser.add_argument('-dmask',
                        metavar='.dmask.csv dnnmask file',
                        type=str, required=True, default=None,
                        help='A *.dmask.csv list of interested layers and channels. ')

    parser.add_argument('-out',
                        metavar='Output stim.hd5 file',
                        type=str, required=True, default=None,
                        help='Output dir to save the top stimulus for interested layers '
                                'and channels, and assocaited *.act.hd5 file. ')

    args = parser.parse_args()

    # --- 判断输入变量合法性 ---
    assert args.metric in ['L1', 'L2', 'mean', 'max', 'median'],\
        'The input -metric is not supported! -metric for top K stimulus are mean, max, L1, L2, median.'

    if not pexist(args.out):
        os.mkdir(args.out)

    # --- 载入mask ---
    dmask = Mask(args.dmask)

    # --- 载入网络 ---
    dnn = DNN(args.net)

    # --- 载入刺激 ---
    stim = Stimulus(args.stim)
    transform = Compose([Resize(dnn.img_size), ToTensor()])
    dataset = ImageSet(stim.meta['path'], stim.get('stimID'), transform=transform)
    stims, _ = dataset[:]

    # --- 提取激活 ---
    acts = []
    data_loader = DataLoader(dataset, batch_size=8, shuffle=False)
    for stims, _ in data_loader:
        acts.append(dnn.compute_activation(stims, dmask))
    act = acts[0].concatenate(acts[1:])

    # --- 计算 topK ---
    for tmp_ly in act.layers:
        tmp_raw = act.get(tmp_ly, raw_shape=True)
        tmp_pool = dnn_pooling(act.get(tmp_ly), args.metric).squeeze(2).T
        if len(tmp_raw) == 2:
            tmp_raw = tuple(np.append(np.array(tmp_raw), [1, 1]))
        toptmp = np.zeros((args.top, len(dmask.get(tmp_ly)['chn']), tmp_raw[2] * tmp_raw[3]))
        for tmp_chn_id, tmp_chn in enumerate(dmask.get(tmp_ly)['chn']):
            tmp_sort_id = np.argsort(-tmp_pool[tmp_chn_id])[0:args.top]
            # --- 写入CSV文件 ---
            tmpCSVname = args.net + '_ly=' + tmp_ly + '_chn=' + str(tmp_chn) + '_top=' + \
                str(args.top) + '_meth=' + args.metric + '.stim.csv'
            stim.set('stimID', dataset.img_ids[tmp_sort_id])
            stim.set('pool', tmp_pool[tmp_chn_id][tmp_sort_id])
            stim.save(pjoin(args.out, tmpCSVname))
            toptmp[:, tmp_chn_id, :] = act.get(tmp_ly)[tmp_sort_id, tmp_chn_id, :]
        # --- 写入H5文件 ---
        act.set(tmp_ly, raw_shape=(args.top, tmp_raw[1], tmp_raw[2], tmp_raw[3]))
        act.set(tmp_ly, toptmp)
    h5name = args.net + '_top=' + str(args.top) + '_meth=' + args.metric + '_mask=' +\
        pbase(args.dmask).rstrip('.dmask.csv') + '.act.h5'
    act.save(pjoin(args.out, h5name))


if __name__ == '__main__':
    main()
