#! /usr/bin/env python
import os
import numpy as np
import torch
import torch.nn as nn

from torch.utils.data import DataLoader, TensorDataset
from torchvision import transforms
from scipy.stats import pearsonr
from sklearn.model_selection import KFold
from dnnbrain.core.models import DNN2BrainNet
from dnnbrain.core.model_operation import truncate_net
from dnnbrain.utils.iofiles import PicDataset, NetLoader, BrainImgLoader


def main():
    import argparse

    parser = argparse.ArgumentParser(description="DNN connect brain")
    parser.add_argument('-in',
                        metavar='stimuli',
                        required=True,
                        type=str,
                        dest='stimuli_dir',
                        help="the directory of the stimuli of the net")
    parser.add_argument('-net',
                        metavar='net_name',
                        required=True,
                        type=str,
                        dest='net_name',
                        help="a neural network's name")
    parser.add_argument('-layer',
                        metavar='layer_number',
                        required=True,
                        type=int,
                        help="The sequence number of the layer which is connected to predict brain activity.")
    parser.add_argument('-channel',
                        metavar='channel_number',
                        type=int,
                        help="The sequence number of the out channel of the selected layer"
                             "If not specified, select all out channels.")
    parser.add_argument('-csv',
                        metavar='csv_file',
                        required=True,
                        type=str,
                        help="map stimulus with brain activation")
    parser.add_argument('-brainact',
                        metavar='brain_data',
                        required=True,
                        type=str,
                        help="brain activation data file")
    parser.add_argument('-mask',
                        metavar='mask_file',
                        type=str,
                        help="brain mask used to extract activation locally")
    parser.add_argument('-cvfold',
                        metavar='fold_number',
                        type=int,
                        help="cross validation fold number")
    parser.add_argument('-out',
                        metavar='output',
                        required=True,
                        type=str,
                        help="output directory")
    args = parser.parse_args()

    # load net and prepare data
    net_loader = NetLoader(args.net)
    pic_dataset = PicDataset(args.csv, args.stimuli_dir,
                             transforms.Compose([transforms.Resize(net_loader.img_size), transforms.ToTensor()]))
    pics = torch.tensor([pic for _, pic, _ in pic_dataset])
    brainact = BrainImgLoader(args.brainact).load_brainimg()
    brainact = torch.tensor(brainact)
    if args.mask:
        brainact_tmp = []
        mask = BrainImgLoader(args.mask).load_brainimg()
        for volume in brainact:
            brainact_tmp.append(volume[mask != 0])
        brainact = torch.tensor(brainact_tmp)
    brainact = brainact.view(brainact.size(0), -1)  # flat the brain activation data

    if args.cvfold:
        # split data to args.cvfold folds
        # Each fold is then used once as a validation while the args.cvfold - 1 remaining folds form the training set.
        pass
    else:
        # use all data to train a model
        # truncate the pretrained neural network
        truncated_net = truncate_net(net_loader.model, args.layer, net_loader.conv_indices)
        for param in truncated_net.parameters():
            # fix the pretrained parameters
            param.requires_grad = False
        truncated_output = truncated_net(pics[0])

        # create new network
        net = DNN2BrainNet(
            truncated_net=truncated_net,
            channel_unit_num=truncated_output.size()[2:].numel(),
            fc_out_num=brainact.size()[1],
            channel=args.channel
        )

        # tensor dataset
        dataset = TensorDataset(pics, brainact)
        train_loader = DataLoader(dataset=dataset, batch_size=8, shuffle=True, num_workers=1)

        # start training
        optimizer = torch.optim.Adam(net.parameters(), lr=0.01)
        loss_func = nn.CrossEntropyLoss()
        for epoch in range(100):
            for step, (img, brainact) in enumerate(train_loader):
                img.require_grad_(True)
                output = net(img)
                loss = loss_func(output, brainact)
                optimizer.zero_grad()
                loss.backward()
                optimizer.step()

        return net


def training(train_pairs, img_dir, brainact, mask_file, img_size, batch_size, shuffle, num_workers,
             src_net, layer, channel):
    """
    create and train a instance of DNN2BrainNet

    :param train_pairs: numpy array
        Each row has two elements. The first is image's filename,
        and the second is brain activation data's filename.
    :param img_dir: str
        the directory of the images
    :param brainact: str
        the directory of the brain activation data
    :param mask_file: str
        the file of the mask data
    :param img_size: iteration and its length is 2
    :param batch_size: int
    :param shuffle: bool
    :param num_workers: int
    :param src_net: torch.nn.Module
        a pretrained neural network
    :param layer: int
        The sequence number of the layer which is connected to predict brain activity.
    :param channel: int
        The sequence number of the out channel of the selected layer
    :return: DNN2BrainNet
        a trained DNN2BrainNet
    """
    train_dataset = ImageBrainactDataset(
        img_brainact_pairs=train_pairs,
        img_dir=img_dir,
        brainact_dir=brainact,
        mask_file=mask_file,
        img_transform=transforms.Compose([
            transforms.Resize(img_size),
            transforms.ToTensor()
        ]),
        brainact_transform=transforms.ToTensor()
    )
    train_loader = DataLoader(
        dataset=train_dataset,
        batch_size=batch_size,
        shuffle=shuffle,
        num_workers=num_workers
    )

    # truncate the pretrained neural network
    truncated_net = truncate_net(src_net, layer)
    for param in truncated_net.parameters():
        # fix the pretrained parameters
        param.requires_grad = False
    truncated_output = truncated_net(train_dataset[0][0])

    # create new network
    net = DNN2BrainNet(
        truncated_net=truncated_net,
        channel_unit_num=truncated_output.size()[2:].numel(),
        fc_out_num=len(train_dataset[0][1]),
        channel=channel
    )

    # start training
    optimizer = torch.optim.Adam(net.parameters(), lr=0.01)
    loss_func = nn.CrossEntropyLoss()
    for epoch in range(100):
        for step, (img, brainact) in enumerate(train_loader):
            img.require_grad_(True)
            output = net(img)
            loss = loss_func(output, brainact)
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

    return net


if __name__ == '__main__':
    main()
